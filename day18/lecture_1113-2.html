<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
        // var는 변수자체 변경가능, let은 변수 재선언은 안되도 변수값 재할당 가능
        // const는 변수값 재할당은 안되는데 객체와 배열 내부 원소값 재할당 가능
        // 선언된 변수는 블록 내에서만 유효하니 주의
        // 자바스크립트는 변수선언이랑 프린트가 3종류가 있어요.
        // 배열의 길이 찾는 함수와 요소추가함수 기억해 주세요
        // 개발자가 의도적으로 변수의 타입을 변환 --> 명시적 변환
        // **자바스크립트 엔진이 자동으로 변수의 타입변환 --> 암묵적 변환
        // 원래 toString 명령어를 써야 문자열 변수로 바뀐다. var x = 10; --> var str = x.toString();
        // 따옴표 사이 문자를 더하기 처리하면 문자열로 바뀐다. var str = x + '';
        // 덧셈은 문자형 처리하면서 숫자를 붙여쓰고, 
        // 뺄셈, 나눗셈과 곱셈은 숫자형 처리하면서 계산
        // 공백과 문자열을 더하기 처리하면 'NAN' 처리되요~~
        // document.write(('b' + 'a' + + 'a' + 'a').toLowerCase());
        // 간단한 조건문에서 중괄호 빼먹어도 돌아가는 경우가 있는데
        // 문제의 소지가 있다.
        // 변수의 범위는 블럭에 한정되는데 (이전 let 예시)
        // 블럭의 범위를 정하는 것이 괄호이기 때문 (변수의 지정범위 이슈)
        // 숫자형을 문자형으로 자료형 바꾸는법. String(1), (1).toString(), 1 + ''
        // 문자형을 숫자형으로 자료형 바꾸는법. Number('0'), parseInt('0'), parseFloat('10.53'), +'0'
        // 불리언 타입으로 바꾸는 법. Boolean('x'), !!'x'
        // Boolean({}) , Boolean([]) 은 True이다.
        // 논리계산에서 논리의 참 거짓을 판별하는 변수가 출력 변수가 된다.
        // 'Cat' && 'Dog' --> “Dog” 둘 다 참인 조건에서는 두번째 변수가 판별변수이고
        // 'Cat' || 'Dog' --> 'Cat' 둘 중 하나가 참인 조건에선 첫번째 변수가 판별변수이다.
        // 논리 계산은 판별 조건을 결정짓는 변수임을 유의
        // JS는 논리연산과 계산의 암묵적 변환에 유의
        // 향후 디버그 시 개발에 어려움을 가져다 줌
        // while에서 블럭이 있으면 각 실행문마다 출력, 없으면 최종결과만
        // switch문은 정수 조건의 if 문과 유사함.
        // **단, while문과 같이 break 조건이 없는 경우 올바른 조건을 찾아도 
        // switch문을 종료시키지 못해서 엉뚱한 결과를 리턴한다.
        // default 문은 switch 문의 가장 마지막에 위치하므로 default 문의 실행이 종료하면 
        // switch 문을 빠져나간다. 따라서 별도로 break 문이 필요없다.
        // **switch문은 특정 조건을 찍어야 하므로 비교연산자 못쓴다. <, >
        // 가독성에 도움이 되지만 fall through, break, default조건 등 
        // 신경써야 할 부분이 많고, 비교연산자 못쓰니까 
        // 조건문의 변수가 실수라면 if로 처리하자.
        // === 는 값 뿐 아니라 자료형까지 일치하는지 본다.
        // *** break outer & inner loop 의 차이 (레이블 문)
        // if (i + j === 6) break outer 조건은 외부 for문을 정지 시키므로 
        // for 문 전체가 정지된다.
        // 그런데 if (i + j === 6) break inner; 조건은 내부 for문을 정지 시키므로
        // 외부 for문의 나머지 요소들은 계속 실행된다.
        // 외부 for문이 끊임없이 6을 향해 탐색을 지속하므로 for문은 지속되고
        // 외부 변수가 6이되면 정지 조건이 무시되므로 boundary컨디션에 위배된다~

// // outer라는 식별자가 붙은 레이블 for 문
// outer: for (var i = 1; i < 7; i++) {
//   inner: for (var j = 1; j < 7; j++) {
//     // i + j === 3이면 외부 for 문을 탈출한다.
//     console.log(i,j);
//     if (i + j === 6) break inner;
//   }
// }

// console.log('Done!');

// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.
// for문이 짧으면 break통한 접근이 좋은 방법이고
// for문의 논리가 복잡하다면 케이스 별로 continue의 활용이 적합하다.
// 그 이유는 continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.
// 그래서 if문 안에 코드를 작성하는 break는 짧을때만 써야한다.






    </script>
  </body>
</html>
